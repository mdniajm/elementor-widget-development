!function(){"use strict";var e={d:function(t,n){for(var r in n)e.o(n,r)&&!e.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:n[r]})},o:function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r:function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{Slot:function(){return p},createInjectorFor:function(){return l},flushInjections:function(){return s},getInjectionsOf:function(){return u},inject:function(){return c},useInjectionsOf:function(){return f}});var n=React;class r extends n.Component{state={hasError:!1};static getDerivedStateFromError(){return{hasError:!0}}render(){return this.state.hasError?this.props.fallback:this.props.children}}function o({children:e}){return React.createElement(r,{fallback:null},React.createElement(n.Suspense,{fallback:null},e))}const i=10,a=new Map;function c({location:e,filler:t,name:n,options:r={}}){const c=function(e,t){return`${e}::${t}`}(e,n);if(a.has(c)&&!r?.overwrite)return void console.error(`An injection named "${n}" under location "${e}" already exists. Did you mean to use "options.overwrite"?`);const l={id:c,location:e,filler:(u=t,e=>React.createElement(o,null,React.createElement(u,e))),priority:r.priority??i};var u;a.set(c,l)}function l(e){return({filler:t,name:n,options:r})=>c({location:e,name:n,filler:t,options:r})}function u(e){return[...a.values()].filter((t=>t.location===e)).sort(((e,t)=>e.priority-t.priority))}function s(){a.clear()}function f(e){return(0,n.useMemo)((()=>Array.isArray(e)?e.map((e=>u(e))):u(e)),[e])}function p({location:e}){const t=f(e);return n.createElement(n.Fragment,null,t.map((({id:e,filler:t})=>n.createElement(t,{key:e}))))}(window.__UNSTABLE__elementorPackages=window.__UNSTABLE__elementorPackages||{}).locations=t}();